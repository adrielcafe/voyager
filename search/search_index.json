{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#voyager-compose-on-warp-speed","title":"Voyager: Compose on Warp Speed","text":"<p>A multiplatform navigation library built for, and seamlessly integrated with, Jetpack Compose.</p> <p>Create scalable Single-Activity apps powered by a pragmatic API:</p> <pre><code>class HomeScreenModel : ScreenModel {\n    // ...\n}\n\nclass HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = rememberScreenModel { HomeScreenModel() }\n        // ...\n    }\n}\n\nclass SingleActivity : ComponentActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContent {\n            Navigator(HomeScreen())\n        }\n    }\n}\n</code></pre> <p>Turn on the Warp Drive and enjoy the voyage \ud83d\udd96</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Supported platforms: Android, iOS, Desktop, Web, Wasm (since 1.1.0-alpha03)</li> <li>Linear navigation</li> <li>BottomSheet navigation</li> <li>Tab navigation like Youtube app</li> <li>Nested navigation (multiple stacks, parent navigation)</li> <li>ScreenModel (a.k.a ViewModel) integrated with Koin, Kodein, Hilt, Coroutines, RxJava, LiveData</li> <li>Android ViewModel integration (with Hilt support)</li> <li>Type-safe multi-module navigation</li> <li>State-aware Stack API</li> <li>Built-in transitions</li> <li>State restoration after Activity recreation</li> <li>Lifecycle callbacks</li> <li>Back press handling</li> <li>Deep linking support</li> <li>Lifecycle KMP support since 1.1.0-beta01</li> </ul>"},{"location":"#credits","title":"Credits","text":"<ul> <li>Logo by Icons8</li> </ul>"},{"location":"back-press/","title":"Back press","text":"<p>By default, Voyager will handle back presses but you can override its behavior. Use the <code>onBackPressed</code> to manually handle it: return <code>true</code> to pop the current screen, or false otherwise. To disable, just set to <code>null</code>.</p> <pre><code>setContent {\n    Navigator(\n        initialScreen = HomeScreen,\n        onBackPressed = { currentScreen -&gt;\n            false // won't pop the current screen\n            // true will pop, default behavior\n        }\n        // To disable:\n        // onBackPressed = null\n    )\n}\n</code></pre>"},{"location":"community-projects/","title":"Community Projects Catalog","text":""},{"location":"community-projects/#open-source-libraries-with-voyager-extensions","title":"Open source libraries with Voyager extensions","text":"<ul> <li>Voyant: An extension library for voyager and Navigation Compose to use native iOS navigation from compose mutltiplatform</li> <li>Kotlin Routing: An extensible and multiplatform routing system powered by Ktor</li> <li>Rinku: Deep Link Handling for Kotlin Multiplatform</li> </ul>"},{"location":"community-projects/#open-source-projects-using-voyager","title":"Open source projects using Voyager","text":"<ul> <li>ClimateTraceKMP: Kotlin/Compose Multiplatform project to show climate related emission data from https://climatetrace.org/data.</li> <li>Suwayomi-JUI: A free and open source manga reader to read manga from a Suwayomi-Server instance.</li> <li>TimePlanner: Mobile app for planning tasks for the day with multimodule architecture, MVI, Compose, Room, Voyager, AlarmManager, Notification, Charts</li> <li>KMP-News-App: This application demonstrates modern Android development with Koin, Ktor, Coroutines, Flows, SQLDelight, Voyager based on Clean Architecture.</li> <li>NationExplorer: Compose Multiplatform App for both Android and iOS designed for discovering and learning more about countries</li> <li>KodeRunner: Compose Your Code, Anywhere, Anytime. Built using Kotlin Multiplatform &amp; Compose Multiplatform \ud83d\ude80</li> <li>Cookit Recipes App: Recipes app for iOS and Android, built with compose multiplatform technology</li> </ul>"},{"location":"community-projects/#talks-and-tutorials","title":"Talks and Tutorials","text":""},{"location":"community-projects/#talks","title":"Talks","text":"<ul> <li>Painless, Typesafe Jetpack Compose Navigation with Voyager -&gt; Source code</li> <li>The Missing Library of the Compose Multiverse | Talking Kotlin #130</li> </ul>"},{"location":"community-projects/#tutorials","title":"Tutorials","text":"<ul> <li>Voyager: Navigation Solution for Compose Multiplatform - iOS and Android | Complete Guide</li> <li>Meet Voyager: A Kotlin Compose Multiplatform Navigation Solution</li> <li>Navigation with Voyager In Jetpack Compose</li> <li>PT-BR Compose Multiplatform - Como Fazer a Navega\u00e7\u00e3o entre Telas com a Biblioteca Voyager</li> </ul>"},{"location":"community-projects/#community-snippetsextensions","title":"Community snippets/extensions","text":"<ul> <li>iOS SwipeBack</li> <li>Predictive Back or with iOS SwipeBack also</li> <li>Result passing between screens, follow the comments for more details.</li> <li>Handle Activity onNewIntent</li> </ul>"},{"location":"deep-links/","title":"Deep links","text":"<p>Warning</p> <p>Currently Voyager does not provided a built in solution to handle Deeplink and URIs. see #149 and #382</p> <p>You can initialize the <code>Navigator</code> with multiple screens, that way, the first visible screen will be the last one and will be possible to return (<code>pop()</code>) to the previous screens.</p> <pre><code>val postId = getPostIdFromIntent()\n\nsetContent {\n    Navigator(\n        HomeScreen,\n        PostListScreen(),\n        PostDetailsScreen(postId)\n    )\n}\n</code></pre>"},{"location":"faq/","title":"Faq","text":"<p>iOS Swipe Back support { #ios-swipeback }</p> <p>Voyager does not have a built in support for swipe back yet, we are not 100% conformable with all solutions that have out there and we think we will better of using a community made solution by copying to your code base and be able to change as you want your app to behave.</p> <p>See this issue each for community build solutions.</p> <p>Alternatively, we can also discuss in the future a community build solution using <code>NavigationController</code> under the hood like <code>compose-cupertino</code> have implemented for Decompose.</p> <p>Support for predictive back animations { #predictive-back }</p> <p>Voyager does not have a built in support for predictive back yet, but as well as iOS Swipe Back, the community have build extensions, and snippets with support, see #223 and 144.</p> <p>Support for result passing between screens { #result-passing }</p> <p>Voyager does not have a built in support for swipe back yet, we are not 100% conformable with all solutions that have out there, we encourage to use community made solutions by copying to your code base and being free to extend as your code base needs.</p> <p>See #128 comments for community solutions.</p> <p>Deeplink support</p>"},{"location":"lifecycle/","title":"Lifecycle","text":"<p>** Experimental API</p> <p>Inside a <code>Screen</code>, you can call <code>LifecycleEffectOnce</code> to execute a block of code the first time the Screen appears, and optionally define a <code>onDispose</code> callback for when the Screen is leaving/removed from the Stack:</p> <pre><code>class PostListScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        LifecycleEffectOnce {\n            screenModel.initSomething()\n            onDispose {\n                // Do something when the screen is leaving/removed from the Stack\n            }\n        }\n\n        // ...\n    }\n}\n</code></pre>"},{"location":"lifecycle/#screenlifecycleowner","title":"ScreenLifecycleOwner","text":"<p> With <code>ScreenLifecycleProvider</code> interface you can provide a special <code>ScreenLifecycleOwner</code> that can react when the Screen leaves the Stack</p> <pre><code>class MyScreenLifecycleOwner : ScreenLifecycleOwner {\n    override fun onDispose(screen: Screen) {\n        println(\"My ${screen.key} is being disposed\")\n    }\n}\n\n\ndata object MyScreen : Screen, ScreenLifecycleProvider {\n   @Composable\n   fun Content() {\n      ...\n   }\n\n   public override fun getLifecycleOwner(): ScreenLifecycleOwner =\n       ScreenLifecycleOwner()\n}\n</code></pre>"},{"location":"lifecycle/#extending-the-lifecycle-lazily","title":"Extending the Lifecycle lazily","text":"<p>You can access directly the <code>ScreenLifecycleStore</code> to add a <code>ScreenDisposable</code> implementation lazily in a lifecycle aware custom API.</p> <p>If you for example have a custom dependency that should be notified when the Screen is disposed you can use the <code>ScreenLifecycleStore</code> directly. For example, the Screen Model and ScreenModelStore APIs rely on this API to Store the ScreenModel instance and the Screen owns the ScreenModel instance,  when the Screen leaves the Stack, the ScreenModelStore, that implements <code>ScreenDisposable</code> is notified and can dispose the ScreenModel.</p> <p>Let\u2019s imagine a dependency called <code>MyDependency</code> that holds and provides a State for a Screen while it is on the Navigator stack and we want to notify <code>MyDependency</code> when the Screen leaves the Stack.</p> <pre><code>class MyCustomAPIWithDisposable(\n   private val myDependency: MyDependency\n) : ScreenDisposable {\n   public override fun onDispose(screen: Screen) {\n      myDependency.disposeStateForScreen(screen)\n   }\n}\n\n@Composable\nfun rememberMyDependency(): MyDependency {\n   val navigator = LocalNavigator.currentOrThrow\n   val myDependency by getMyDependecy() // getting from DI\n   remember(myDependency) {\n      myDependency.provideStateForScreen(navigator.lastItem)\n      ScreenLifecycleStore.get(navigator.lastItem) {\n         MyCustomAPIWithDisposable(myDependency)\n      }\n   }\n\n   return myDependency\n}\n</code></pre>"},{"location":"lifecycle/#screendisposable-for-all-screens","title":"ScreenDisposable for all Screens","text":"<p>You can also provide a <code>ScreenLifecycleOwner</code> for all Screen in the stack of a Navigator easily by in the Navigator composable start to listen to <code>lastItem</code> for registering at <code>ScreenLifecycleStore.</code></p> <p>Let\u2019s reuse the <code>MyScreenLifecycleOwner</code> from the example above and provide it to all screens in the navigator.</p> <pre><code>class MyScreenLifecycleOwner : ScreenDisposable {\n    override fun onDispose(screen: Screen) {\n        println(\"My ${screen.key} is being disposed\")\n    }\n}\n\n@Composable\nfun YourAppComposable() {\n  Navigator(...) { navigator -&gt;\n     remember(navigator.lastItem) {\n        ScreenLifecycleStore.get(navigator.lastItem) {\n           MyScreenLifecycleOwner()\n        }\n     }\n     CurrentScreen()\n  }\n}\n</code></pre>"},{"location":"migration-to-1.0.0/","title":"Migration to 1.0.0","text":""},{"location":"migration-to-1.0.0/#screenmodel","title":"ScreenModel","text":""},{"location":"migration-to-1.0.0/#new-module","title":"New Module","text":"<p>Now the ScreenModel API has its own module and no longer are available in <code>voyager-core</code>, if you are using ScreenModel you should declare the dependency <code>cafe.adriel.voyager:voyager-screenmodel</code> (see Setup).</p>"},{"location":"migration-to-1.0.0/#navigation-level-screenmodel","title":"Navigation level ScreenModel","text":"<p>Since 1.0.0-rc08 we have introduced the ScreenModel scoped at Navigator Lifecycle, now the API is no longer marked as Experimental.</p>"},{"location":"migration-to-1.0.0/#deprecation-cycle","title":"Deprecation cycle","text":"<p>Since <code>1.0.0-rc08</code> we have renamed the extension <code>coroutineScope</code> to <code>screenModelScope</code>, now it was removed from 1.0.0, if you are still using it, just replace with <code>screenModelScope.</code></p>"},{"location":"migration-to-1.0.0/#androidscreen","title":"AndroidScreen","text":"<p>The module <code>voyager-androidx</code> and <code>AndroidScreen</code> was removed! Since <code>1.0.0-rc06</code> we have introduced a new API called <code>NavigatorScreenLifecycleProvider</code> that provides by default the previous behavior of <code>AndroidScreenLifecycleOwner</code> on Android target for all Screen.</p> <p>Important notice: AndroidScreen, different from Screen, it holds the <code>Screen.key</code> as a <code>uniqueScreenKey</code>, this is a pretty common requirement, to avoid issues and weird behaviors, we recommend continuing to specify a <code>uniqueScreenKey</code> if you are not, we also recommend creating a <code>abstract class UniqueScreen</code> to replace your  <code>AndroidScreen</code> implementation.</p> <pre><code>abstract class UniqueScreen : Screen {\n    override val key: ScreenKey = uniqueScreenKey\n}\n</code></pre>"},{"location":"migration-to-1.0.0/#apis-promote-to-stable","title":"APIs promote to Stable","text":"<ul> <li>All Navigator scoped ScreenModels API</li> <li><code>NavigatorLifecycleStore</code> and <code>NavigatorDisposable</code></li> <li><code>TabDisposable</code></li> </ul>"},{"location":"migration-to-1.0.0/#deprecation-cycle_1","title":"Deprecation cycle","text":"<ul> <li><code>ScreenLifecycleStore.get</code>: Use <code>register</code> or new <code>get</code> function instead.</li> <li><code>Stack.lastOrNull</code>: Use <code>lastItemOrNull</code> instead</li> <li><code>Navigator.last</code>: Use <code>lastItem</code> instead</li> <li><code>ScreenModel.coroutineScope</code>: Use <code>screenModelScope</code> instead </li> <li><code>ScreenModelStore.remove</code>: Use <code>onDispose</code> instead.</li> <li><code>Tab.title</code>: Use <code>options</code> instead.</li> <li><code>Tab.icon</code>: Use <code>options</code> instead.</li> </ul>"},{"location":"setup/","title":"Setup","text":"<ol> <li> <p>Add Maven Central to your repositories if needed</p> <p><pre><code>repositories {\n    mavenCentral()\n}\n</code></pre> 2. Add the desired dependencies to your module\u2019s <code>build.gradle</code> file</p> </li> </ol> DependenciesVersion Catalog <pre><code>dependencies {\n    val voyagerVersion = \"1.1.0-beta02\"\n\n    // Multiplatform\n\n    // Navigator\n    implementation(\"cafe.adriel.voyager:voyager-navigator:$voyagerVersion\")\n\n    // Screen Model\n    implementation(\"cafe.adriel.voyager:voyager-screenmodel:$voyagerVersion\")\n\n    // BottomSheetNavigator\n    implementation(\"cafe.adriel.voyager:voyager-bottom-sheet-navigator:$voyagerVersion\")\n\n    // TabNavigator\n    implementation(\"cafe.adriel.voyager:voyager-tab-navigator:$voyagerVersion\")\n\n    // Transitions\n    implementation(\"cafe.adriel.voyager:voyager-transitions:$voyagerVersion\")\n\n    // Koin integration\n    implementation(\"cafe.adriel.voyager:voyager-koin:$voyagerVersion\")\n\n    // Android\n\n    // Hilt integration\n    implementation(\"cafe.adriel.voyager:voyager-hilt:$voyagerVersion\")\n\n    // LiveData integration\n    implementation(\"cafe.adriel.voyager:voyager-livedata:$voyagerVersion\")\n\n    // Desktop + Android\n\n    // Kodein integration\n    implementation(\"cafe.adriel.voyager:voyager-kodein:$voyagerVersion\")\n\n    // RxJava integration\n    implementation(\"cafe.adriel.voyager:voyager-rxjava:$voyagerVersion\")\n}\n</code></pre> <pre><code>[versions]\nvoyager = \"1.1.0-beta02\"\n\n[libraries]\nvoyager-navigator = { module = \"cafe.adriel.voyager:voyager-navigator\", version.ref = \"voyager\" }\nvoyager-screenModel = { module = \"cafe.adriel.voyager:voyager-screenmodel\", version.ref = \"voyager\" }\nvoyager-bottomSheetNavigator = { module = \"cafe.adriel.voyager:voyager-bottom-sheet-navigator\", version.ref = \"voyager\" }\nvoyager-tabNavigator = { module = \"cafe.adriel.voyager:voyager-tab-navigator\", version.ref = \"voyager\" }\nvoyager-transitions = { module = \"cafe.adriel.voyager:voyager-transitions\", version.ref = \"voyager\" }\nvoyager-koin = { module = \"cafe.adriel.voyager:voyager-koin\", version.ref = \"voyager\" }\nvoyager-hilt = { module = \"cafe.adriel.voyager:voyager-hilt\", version.ref = \"voyager\" }\nvoyager-kodein = { module = \"cafe.adriel.voyager:voyager-kodein\", version.ref = \"voyager\" }\nvoyager-rxjava = { module = \"cafe.adriel.voyager:voyager-rxjava\", version.ref = \"voyager\" }\n</code></pre> <p>Current version here.</p>"},{"location":"setup/#platform-compatibility","title":"Platform compatibility","text":"<p>Multiplatform targets: Android, iOS, Desktop, Mac Native, Web.</p> Android Desktop Multiplatform voyager-navigator voyager-screenModel voyager-bottom-sheet-navigator voyager-tab-navigator voyager-transitions voyager-koin voyager-kodein voyager-lifecycle-kmp voyager-hilt voyager-rxjava voyager-livedata"},{"location":"stack-api/","title":"Stack API","text":""},{"location":"stack-api/#snapshotstatestack","title":"SnapshotStateStack","text":"<p>Voyager is backed by a SnapshotStateStack:</p> <ul> <li>Implementation of Stack that can be observed and snapshot</li> <li>Internally uses a SnapshotStateList</li> <li>State-aware: content change triggers a recomposition</li> </ul> <p>You will use it to navigate forward (<code>push</code>, <code>replace</code>, <code>replaceAll</code>) and backwards (<code>pop</code>, <code>popAll</code>, <code>popUntil</code>), but the <code>SnapshotStateStack</code> can also be used as a regular collection outside the <code>Navigator</code>.</p> <pre><code>val stack = mutableStateStackOf(\"\ud83c\udf47\", \"\ud83c\udf49\", \"\ud83c\udf4c\", \"\ud83c\udf50\", \"\ud83e\udd5d\", \"\ud83c\udf4b\")\n// \ud83c\udf47, \ud83c\udf49, \ud83c\udf4c, \ud83c\udf50, \ud83e\udd5d, \ud83c\udf4b\n\nstack.lastItemOrNull\n// \ud83c\udf4b\n\nstack.push(\"\ud83c\udf4d\")\n// \ud83c\udf47, \ud83c\udf49, \ud83c\udf4c, \ud83c\udf50, \ud83e\udd5d, \ud83c\udf4b, \ud83c\udf4d\n\nstack.pop()\n// \ud83c\udf47, \ud83c\udf49, \ud83c\udf4c, \ud83c\udf50, \ud83e\udd5d, \ud83c\udf4b\n\nstack.popUntil { it == \"\ud83c\udf50\" }\n// \ud83c\udf47, \ud83c\udf49, \ud83c\udf4c, \ud83c\udf50\n\nstack.replace(\"\ud83c\udf53\")\n// \ud83c\udf47, \ud83c\udf49, \ud83c\udf4c, \ud83c\udf53\n\nstack.replaceAll(\"\ud83c\udf52\")\n// \ud83c\udf52\n</code></pre> <p>You can also create a <code>SnapshotStateStack</code> through <code>rememberStateStack()</code>, it will restore the values after Activity recreation.</p>"},{"location":"stack-api/#events","title":"Events","text":"<p>Whenever the content changes, the <code>SnapshotStateStack</code> will emit a <code>StackEvent</code>. Use the <code>stack.lastEvent</code> to get the most recent one.</p> <p>The available events are:</p> <ul> <li><code>Push</code>: whenever <code>push</code> is called</li> <li><code>Replace</code>: whenever <code>replace</code> and <code>replaceAll</code> are called</li> <li><code>Pop</code>: whenever <code>pop</code> and <code>popAll</code> are called</li> <li><code>Idle</code>: default event</li> </ul> <p>This is very useful for deciding which transition to make.</p>"},{"location":"stack-api/#sample","title":"Sample","text":"<p>Info</p> <p>Source code here.</p>"},{"location":"state-restoration/","title":"State restoration","text":"<p>Voyager by default expect that it screens can be stored inside a Bundle. This means both Java Serializable and Parcelable are supported. By default all Voyager Screen is Java Serializable this means that Screen can be restored if all parameters are Java Serializable.</p>"},{"location":"state-restoration/#java-serializable","title":"Java Serializable","text":"<pre><code>// \u2714\ufe0f DO\ndata class Post(/*...*/) : Serializable\n\ndata class ValidScreen(\n    val userId: UUID, // Built-in serializable types\n    val post: Post // Your own serializable types\n) : Screen {\n    // ...\n}\n\n// \ud83d\udeab DON'T\nclass Post(/*...*/)\n\ndata class InvalidScreen(\n    val context: Context, // Built-in non-serializable types\n    val post: Post, // Your own non-serializable types\n    val parcelable: SomeParcelable // Android Parcelable is not Java Serializable by default\n) : Screen {\n    // ...\n}\n</code></pre> <p>Not only the params, but the properties will also be restored, so the same rule applies.</p> <pre><code>// \u2714\ufe0f DO\nclass ValidScreen : Screen {\n\n    // Serializable properties\n    val tag = \"ValidScreen\"\n\n    // Lazily initialized serializable types\n    val randomId by lazy { UUID.randomUUID() }\n}\n\n// \ud83d\udeab DON'T\nclass InvalidScreen : Screen {\n\n    // Non-serializable properties\n    val postService = PostService()\n}\n</code></pre>"},{"location":"state-restoration/#android-parcelables","title":"Android Parcelables","text":"<pre><code>// \u2714\ufe0f DO\n@Parcelize\ndata class Post(/*...*/) : Parcelable\n\n@Parcelize\ndata class ValidScreen(\n    val post: Post // Your own parcelable types\n) : Screen, Parcelable {\n    // ...\n}\n\n// \ud83d\udeab DON'T\nclass Post(/*...*/)\n\n@Parcelize\ndata class InvalidScreen(\n    val context: Context, // Built-in non-parcelable types\n    val post: Post, // Your own non-parcelable types\n    val serializable: SomeSerializable // Java Serializable are not Android Parcelable by default\n) : Screen, Parcelable {\n    // ...\n}\n</code></pre>"},{"location":"state-restoration/#enforcing-android-parcelable-on-your-screens","title":"Enforcing Android Parcelable on your screens","text":"<p>You can build your own Screen type for enforcing in at compile time that all yours screens should be Parcelable by creating an interface that implement Parcelable.</p> <pre><code>interface ParcelableScreen : Screen, Parcelable\n\n// Compile\n@Parcelize\ndata class Post(/*...*/) : Parcelable\n\n@Parcelize\ndata class ValidScreen(\n    val post: Post\n) : ParcelableScreen {\n    // ...\n}\n\n// Not compile\ndata class Post(/*...*/)\n\n@Parcelize\ndata class ValidScreen(\n    val post: Post\n) : ParcelableScreen {\n    // ...\n}\n</code></pre> <p>Starting from version 1.0.0-rc05 you can specify a custom NavigatorSaver to enforce that all Screen is Parcelable by using <code>parcelableNavigatorSaver</code>.</p> <pre><code>CompositionLocalProvider(\n    LocalNavigatorSaver provides parcelableNavigatorSaver()\n) {\n    Navigator(...) {\n       ...\n    }\n}\n</code></pre>"},{"location":"state-restoration/#multiplatform-state-restoration","title":"Multiplatform state restoration","text":"<p>When working in a Multiplatform project and sharing the Parameters models with other platforms, your types required to be serializable in a  Bundle if you are targeting Android, the easiest way is defining in common code a <code>JavaSerializable</code> interface that on Android only would implement <code>java.io.Serialiable</code>, see example below.</p> <pre><code>// commonMain - module core\nexpect interface JavaSerializable\n\ndata class Post(/*...*/) : JavaSerializable\n\n// androidMain - module core\nactual typealias JavaSerializable = java.io.Serializable\n\n// non AndroidMain (ios, web, etc) - module core\nactual interface JavaSerializable\n\n// android ui module or compose multiplatform module\ndata class ValidScreen(\n    val post: Post\n) : Screen\n</code></pre>"},{"location":"state-restoration/#dependency-injection","title":"Dependency Injection","text":"<p>If you want to inject dependencies through a DI framework, make sure it supports Compose, like Koin and Kodein.</p> <pre><code>// \u2714\ufe0f DO\nclass ValidScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        // Inject your dependencies inside composables\n        val postService = get&lt;PostService&gt;()\n    }\n}\n\n// \ud83d\udeab DON'T\nclass InvalidScreen : Screen {\n\n    // Using DI to inject non-serializable types as properties\n    val postService by inject&lt;PostService&gt;()\n}\n</code></pre>"},{"location":"state-restoration/#identifying-screens","title":"Identifying screens","text":"<p>The <code>Screen</code> interface has a <code>key</code> property used for saving and restoring the states for the subtree. You can override the default value to set your own key.</p> <pre><code>class HomeScreen : Screen {\n\n    override val key = \"CUSTOM_KEY\"\n\n    @Composable\n    override fun Content() {\n        // ...\n    }\n}\n</code></pre> <p>Voyager provides a <code>uniqueScreenKey</code> property, useful if you don\u2019t want to manage the keys yourself.</p> <pre><code>override val key = uniqueScreenKey\n</code></pre> <p>Warning</p> <p>You should always set your own key if the screen:</p> <ul> <li>Is used multiple times in the same <code>Navigator</code></li> <li>Is an anonymous or local class</li> </ul>"},{"location":"transitions-api/","title":"Transitions","text":"<p>To use the transitions you should first import <code>cafe.adriel.voyager:voyager-transitions</code> (see Setup).</p> <p>Voyager has built-in transitions! When initializing the <code>Navigator</code> you can override the default content and use, for example, the <code>SlideTransition</code>.</p> <pre><code>setContent {\n    Navigator(HomeScreen) { navigator -&gt;\n        SlideTransition(navigator)\n    }\n}\n</code></pre> <p>Known bug</p> <p>There is a known bug using any Transition APIs can leaky ScreenModels or ViewModels, this happens because Voyager by default dispose Screens in the next Composition tick after a <code>pop</code> or <code>replace</code> is called, but the transition only finish later, so the ScreenModel or ViewModel is re created or cleared to early. For this purpose since Voyager <code>1.1.0-beta02</code> we have introduce a new API to fix this issue. For more details on the issue see #106.</p> <pre><code>Navigator(\n    screen = ...,\n    disposeBehavior = NavigatorDisposeBehavior(disposeSteps = false),\n) { navigator -&gt;\n    SlideTransition(\n        navigator = navigator,\n        ...\n        disposeScreenAfterTransitionEnd = true\n    )\n}\n</code></pre> <p>Warning</p> <p>Have encounter <code>Screen was used multiple times</code> crash? Provide a <code>uniqueScreenKey</code> for your Screens</p> <pre><code>class ScreenFoo : Screen {\n\n    override val key: ScreenKey = uniqueScreenKey\n\n    @Composable\n    override fun Content() {\n        ...\n    }\n</code></pre>"},{"location":"transitions-api/#available-transitions","title":"Available transitions","text":"<code>FadeTransition()</code> <code>SlideTransition()</code> <code>ScaleTransition()</code>"},{"location":"transitions-api/#custom-transitions","title":"Custom transitions","text":"<p>It\u2019s simple to add your own transitions: call <code>ScreenTransition</code> with a custom <code>transitionModifier</code>. Use the available params (<code>screen</code>, <code>transition</code> and <code>event</code>) to animate as needed.</p> <pre><code>@Composable\nfun MyCustomTransition(\n    navigator: Navigator,\n    modifier: Modifier = Modifier,\n    content: ScreenTransitionContent\n) {\n    ScreenTransition(\n        navigator = navigator,\n        modifier = modifier,\n        content = content,\n        transition = {\n            val (initialScale, targetScale) = when (navigator.lastEvent) {\n                StackEvent.Pop -&gt; ExitScales\n                else -&gt; EnterScales\n            }\n\n            scaleIn(initialScale) with scaleOut(targetScale)\n        }\n    )\n}\n\nsetContent {\n    Navigator(HomeScreen) { navigator -&gt;\n        MyCustomTransition(navigator) { screen -&gt;\n            screen.Content()\n        }\n    }\n}\n</code></pre> <p>Take a look at the source of the available transitions for working examples.</p>"},{"location":"transitions-api/#per-screen-transitions-experimental","title":"Per Screen transitions [Experimental]","text":"<p>If you want to define a Enter and Exit transition for a specific Screen, you have a lot of options to do starting from 1.1.0-beta01 Voyager have a new experimental API for this purpose. To animate the content, we use transitions of the target screen in the case of push navigation, otherwise we use transitions of the initial screen </p> <pre><code>class ExampleSlideScreen : Screen, ScreenTransition {\n    override val key: ScreenKey\n        get() = uniqueScreenKey\n\n    @Composable\n    override fun Content() {\n        ...\n    }\n\n    override fun enter(lastEvent: StackEvent): EnterTransition {\n        return slideIn { size -&gt;\n            val x = if (lastEvent == StackEvent.Pop) -size.width else size.width\n            IntOffset(x = x, y = 0)\n        }\n    }\n\n    override fun exit(lastEvent: StackEvent): ExitTransition {\n        return slideOut { size -&gt;\n            val x = if (lastEvent == StackEvent.Pop) size.width else -size.width\n            IntOffset(x = x, y = 0)\n        }\n    }\n}\n</code></pre> <p>It\u2019s convenient to use Kotlin delegates for per-Screen transitions. For example, you can create a <code>SlideTransition</code> and <code>FadeTransition</code> classes:</p> <pre><code>class FadeTransition : ScreenTransition {\n\n    override fun enter(lastEvent: StackEvent): EnterTransition {\n        return fadeIn(tween(500, delayMillis = 500))\n    }\n\n    override fun exit(lastEvent: StackEvent): ExitTransition {\n        return fadeOut(tween(500))\n    }\n}\n\nclass SlideTransition : ScreenTransition {\n\n    override fun enter(lastEvent: StackEvent): EnterTransition {\n        return slideIn { size -&gt;\n            val x = if (lastEvent == StackEvent.Pop) -size.width else size.width\n            IntOffset(x = x, y = 0)\n        }\n    }\n\n    override fun exit(lastEvent: StackEvent): ExitTransition {\n        return slideOut { size -&gt;\n            val x = if (lastEvent == StackEvent.Pop) size.width else -size.width\n            IntOffset(x = x, y = 0)\n        }\n    }\n}\n</code></pre> <p>Then you can use them as delegates in your Screens:</p> <pre><code>class SlideScreen : Screen, ScreenTransition by SlideTransition() {\n\n    @Composable\n    override fun Content() {\n        ...\n    }\n}\n\nclass FadeScreen : Screen, ScreenTransition by FadeTransition() {\n\n    @Composable\n    override fun Content() {\n        ...\n    }\n}\n</code></pre> <p>Also you can use can pass your custom <code>ScreenTransition</code> instance in <code>ScreenTransition</code> function, it will be used for default animation.</p> <pre><code>setContent {\n    Navigator(FadeScreen) { navigator -&gt;\n        ScreenTransition(\n            navigator = navigator,\n            defaultTransition = SlideTransition()\n        )\n    }\n}\n</code></pre> <p>The API works with any ScreenTransition API, you just need to provide one and the Per Screen transition should. <pre><code>setContent {\n    Navigator(HomeScreen) { navigator -&gt;\n        SlideTransition(navigator)\n    }\n}\n</code></pre></p> <p><code>CrossfadeTransition</code> is not supported yet.</p>"},{"location":"android-viewmodel/","title":"Android ViewModel","text":"<pre><code>class PostListScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val viewModel = viewModel&lt;PostListViewModel&gt;()\n        // ...\n    }\n}\n</code></pre> <p>By default Voyager provides its own <code>LocalViewModelStoreOwner</code> and <code>LocalSavedStateRegistryOwner</code>, that way you can safely create <code>ViewModel</code>s without depending on <code>Activity</code> or <code>Fragment</code>.</p> <p>Info</p> <p>Voyager provides a similar implementation, the ScreenModel, which does the same as <code>ViewModel</code> but also works with Compose Multiplatform.</p>"},{"location":"android-viewmodel/#sample","title":"Sample","text":"<p>Info</p> <p>Source code here.</p>"},{"location":"android-viewmodel/hilt-integration/","title":"Hilt integration","text":"<p>Success</p> <p>To use the <code>getViewModel</code> you should first import <code>cafe.adriel.voyager:voyager-hilt</code> (see Setup).</p>"},{"location":"android-viewmodel/hilt-integration/#inject","title":"@Inject","text":"<p>Add <code>@HiltViewModel</code> and <code>@Inject</code> annotations to your <code>ViewModel</code>.</p> <pre><code>@HiltViewModel\nclass HomeViewModel @Inject constructor() : ViewModel() {\n    // ...\n}\n</code></pre> <p>Call <code>getViewModel()</code> to get a new instance.</p> <pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = getViewModel&lt;HomeScreenModel&gt;()\n        // ...\n    }\n}\n</code></pre>"},{"location":"android-viewmodel/hilt-integration/#assistedinject","title":"@AssistedInject","text":"<p>Currently there\u2019s no Assisted Injection support for Hilt ViewModels (issue).</p>"},{"location":"android-viewmodel/hilt-integration/#sample","title":"Sample","text":"<p>Info</p> <p>Sample code here.</p>"},{"location":"android-viewmodel/viewmodel-kmp/","title":"ViewModel KMP","text":"<p>Since 1.1.0-beta01 we have introduce a experimental API for ViewModel KMP. It is under the package <code>cafe.adriel.voyager:voyager-lifecycle-kmp</code>  (see Setup).</p> <p>You will need to call <code>ProvideNavigatorLifecycleKMPSupport</code> before all <code>Navigator</code> calls and it will be working out of the box.</p> <pre><code>@Composable\nfun MainView() {\n    ProvideNavigatorLifecycleKMPSupport {\n        Navigator(...)\n    }\n}\n\nclass MyScreen : Screen {\n    @Composable\n    fun Content() {\n        val myViewModel = viewModel { MyScreenViewModel() }\n    }\n}\n</code></pre>"},{"location":"android-viewmodel/viewmodel-kmp/#navigator-scoped-viewmodel","title":"Navigator scoped ViewModel","text":"<p>Voyager 1.1.0-beta01 also have introduced the support for Navigator scoped ViewModel and Lifecycle. This will make easy to share a ViewModel cross screen of the same navigator.</p> <pre><code>class MyScreen : Screen {\n    @Composable\n    fun Content() {\n        val myViewModel = navigatorViewModel { MyScreenViewModel() }\n    }\n}\n</code></pre>"},{"location":"android-viewmodel/viewmodel-kmp/#lifecycle-kmp","title":"Lifecycle KMP","text":"<p>This version also brings the Lifecycle events for Screen lifecycle in KMP, now is possible to a generic third party API that listen to Lifecycle of a Screen in KMP.</p>"},{"location":"navigation/","title":"Navigation","text":"<p>Success</p> <p>To use the <code>Navigator</code> you should first import <code>cafe.adriel.voyager:voyager-navigator</code> (see Setup).</p>"},{"location":"navigation/#screen","title":"Screen","text":"<p>On Voyager, screens are just classes with a composable function as the entrypoint. To create one, you should implement the <code>Screen</code> interface and override the <code>Content()</code> composable function.</p> <p>You can use <code>data class</code> (if you need to send params), <code>class</code> (if no param is required).</p> <pre><code>class PostListScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        // ...\n    }\n}\n\ndata class PostDetailsScreen(val postId: Long) : Screen {\n\n    @Composable\n    override fun Content() {\n        // ...\n    }\n}\n</code></pre>"},{"location":"navigation/#navigator","title":"Navigator","text":"<p><code>Navigator</code> is a composable function deeply integrated with Compose internals. It\u2019ll manage the lifecyle, back press, state restoration and even nested navigation for you.</p> <p>To start using it, just set the initial <code>Screen</code>.</p> <pre><code>class SingleActivity : ComponentActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContent {\n            Navigator(HomeScreen)\n        }\n    }\n}\n</code></pre> <p>Use the <code>LocalNavigator</code> to navigate to other screens. Take a look at the Stack API for the available operations.</p> <pre><code>class PostListScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        // ...\n    }\n\n    @Composable\n    private fun PostCard(post: Post) {\n        val navigator = LocalNavigator.currentOrThrow\n\n        Card(\n            modifier = Modifier.clickable { \n                navigator.push(PostDetailsScreen(post.id))\n                // Also works:\n                // navigator push PostDetailsScreen(post.id)\n                // navigator += PostDetailsScreen(post.id)\n            }\n        ) {\n            // ...\n        }\n    }\n}\n</code></pre> <p>If part of your UI is shared between screens, like the <code>TopAppBar</code> or <code>BottomNavigation</code>, you can easily reuse them with Voyager.</p> <pre><code>@Composable\noverride fun Content() {\n    Navigator(HomeScreen) { navigator -&gt;\n        Scaffold(\n            topBar = { /* ... */ },\n            content = { CurrentScreen() },\n            bottomBar = { /* ... */ }\n        )\n    }\n}\n</code></pre> <p>{% hint style=\u201dwarning\u201d %} You should use <code>CurrentScreen()</code> instead of <code>navigator.lastItem.Content()</code>, because it will save the Screen\u2019s subtree for you (see SaveableStateHolder). {% endhint %}</p>"},{"location":"navigation/#sample","title":"Sample","text":"<p>Info</p> <p>Source code here.</p>"},{"location":"navigation/bottomsheet-navigation/","title":"BottomSheet navigation","text":"<p>Success</p> <p>To use the <code>BottomSheetNavigator</code> you should first import <code>cafe.adriel.voyager:voyager-bottom-sheet-navigator</code> (see Setup).</p> <p>Voyager provides a specialized navigator for <code>ModalBottomSheetLayout</code>: the <code>BottomSheetNavigator</code>.</p> <p>Call it and set the back layer content. The BottomSheet content (or the front layer) will be set on demand.</p> <pre><code>setContent {\n    BottomSheetNavigator {\n        BackContent()\n    }\n}\n</code></pre> <p>You can also use the default <code>Navigator</code> to navigate on your back layer content.</p> <pre><code>setContent {\n    BottomSheetNavigator {\n        Navigator(BackScreen())\n    }\n}\n</code></pre> <p>The <code>BottomSheetNavigator</code> accepts the same params as <code>ModalBottomSheetLayout</code>.</p> <pre><code>@Composable\npublic fun BottomSheetNavigator(\n    modifier: Modifier = Modifier,\n    hideOnBackPress: Boolean = true,\n    scrimColor: Color = ModalBottomSheetDefaults.scrimColor,\n    sheetShape: Shape = MaterialTheme.shapes.large,\n    sheetElevation: Dp = ModalBottomSheetDefaults.Elevation,\n    sheetBackgroundColor: Color = MaterialTheme.colors.surface,\n    sheetContentColor: Color = contentColorFor(sheetBackgroundColor),\n    // ...\n)\n</code></pre> <p>Use the <code>LocalBottomSheetNavigator</code> to show and hide the BottomSheet.</p> <pre><code>class BackScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val bottomSheetNavigator = LocalBottomSheetNavigator.current\n\n        Button(\n            onClick = { \n                bottomSheetNavigator.show(FrontScreen())\n            }\n        ) {\n            Text(text = \"Show BottomSheet\")\n        }\n    }\n}\n</code></pre>"},{"location":"navigation/bottomsheet-navigation/#sample","title":"Sample","text":"<p>Info</p> <p>Source code here.</p>"},{"location":"navigation/multi-module-navigation/","title":"Multi-module navigation","text":"<p>Voyager has built-in support for multi-module navigation. Its API is based on great DI frameworks like Koin and Kodein, so should be familiar to use.</p> <p>Suppose we have the following modules:</p> <ul> <li><code>app</code>: the entrypoint of our app, contains the Activity</li> <li><code>feature-home</code>: contains the root screen (<code>HomeScreen</code>)</li> <li><code>feature-posts</code>: contains screens related to the posts feature (<code>ListScreen</code> and <code>DetailsScreen</code>)</li> <li><code>navigation</code>: contains the screen providers used to navigate between modules, both <code>feature-home</code> and <code>feature-posts</code> imports it</li> </ul> <p>To navigate from <code>HomeScreen</code> to the screens on <code>feature-posts</code> module (<code>ListScreen</code> and <code>DetailsScreen</code>), we first need to provide them. The <code>navigation</code> module should declare all shared screens in the app,  use the <code>ScreenProvider</code> interface for that.</p> navigation/../SharedScreen.kt<pre><code>sealed class SharedScreen : ScreenProvider {\n    object PostList : SharedScreen()\n    data class PostDetails(val id: String) : SharedScreen()\n}\n</code></pre> <p>Now use the <code>ScreenRegistry</code> to register these providers. This should be done in your<code>Application</code> class.</p> app/../MyApp.kt<pre><code>class MyApp : Application() {\n\n    override fun onCreate() {\n        super.onCreate()\n\n        ScreenRegistry {\n            register&lt;SharedScreen.PostList&gt; {\n                ListScreen()\n            }\n            register&lt;SharedScreen.PostDetails&gt; { provider -&gt;\n                DetailsScreen(id = provider.id)\n            }\n        }\n    }\n}\n</code></pre> <p>You can also create a <code>screenModule</code> into your feature module, that way your <code>Application</code> class won\u2019t be bloated by too many declarations.</p> ScreenModule feature-posts/../ScreenModule.kt<pre><code>val featurePostsScreenModule = screenModule {\n    register&lt;SharedScreen.PostList&gt; {\n        ListScreen()\n    }\n    register&lt;SharedScreen.PostDetails&gt; { provider -&gt;\n        DetailsScreen(id = provider.id)\n    }\n}\n</code></pre> app/../MyApp.kt<pre><code>override fun onCreate() {\n    super.onCreate()\n\n    ScreenRegistry {\n        featurePostsScreenModule()\n    }\n}\n</code></pre> <p>Finally, call <code>rememberScreen()</code> (inside a composable function) or <code>ScreenRegistry.get()</code> to access your screens.</p> feature-home/../HomeScreen.kt<pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val navigator = LocalNavigator.currentOrThrow\n        val postListScreen = rememberScreen(SharedScreen.PostList)\n        val postDetailsScreen = rememberScreen(SharedScreen.PostDetails(id = postId))\n\n        // navigator.push(postListScreen)\n        // navigator.push(postDetailsScreen)\n    }\n}\n</code></pre>"},{"location":"navigation/multi-module-navigation/#sample","title":"Sample","text":"<p>Info</p> <p>Source code here.</p>"},{"location":"navigation/nested-navigation/","title":"Nested navigation","text":""},{"location":"navigation/nested-navigation/#nested-navigators","title":"Nested Navigators","text":"<p>Going a little further, it\u2019s possible to have nested navigators. The <code>Navigator</code> has a <code>level</code> property (so you can check how deeper your are) and can have a <code>parent</code> navigator (if you need to interact with it).</p> <pre><code>setContent {\n    Navigator(ScreenA) { navigator0 -&gt;\n        println(navigator.level)\n        // 0\n        println(navigator.parent == null)\n        // true\n        Navigator(ScreenB) { navigator1 -&gt;\n            println(navigator.level)\n            // 1\n            println(navigator.parent == navigator0)\n            // true\n            Navigator(ScreenC) { navigator2 -&gt;\n                println(navigator.level)\n                // 2\n                println(navigator.parent == navigator1)\n                // true\n            }\n        }\n    }\n}\n</code></pre> <p>Another operation is the <code>popUntilRoot()</code>, it will recursively pop all screens starting from the leaf navigator until the root one.</p>"},{"location":"navigation/nested-navigation/#sample","title":"Sample","text":"<p>Info</p> <p>Source code here.</p>"},{"location":"navigation/tab-navigation/","title":"Tab navigation","text":"<p>Success</p> <p>To use the <code>TabNavigator</code> you should first import <code>cafe.adriel.voyager:voyager-tab-navigator</code> (see Setup).</p> <p>Voyager provides a specialized navigator for tabs : the <code>TabNavigator</code>.</p> <p>The <code>Tab</code> interface, like the <code>Screen</code>, has a <code>Content()</code> composable function, but also requires a <code>TabOptions</code>. </p> <pre><code>object HomeTab : Tab {\n\n    override val options: TabOptions\n        @Composable\n        get() {\n            val title = stringResource(R.string.home_tab)\n            val icon = rememberVectorPainter(Icons.Default.Home)\n\n            return remember {\n                TabOptions(\n                    index = 0u,\n                    title = title,\n                    icon = icon\n                )\n            }\n        }\n\n    @Composable\n    override fun Content() {\n        // ...\n    }\n}\n</code></pre> <p>Info</p> <p>Since tabs aren\u2019t usually reused, its OK to create them as <code>object</code>.</p> <p>The <code>TabNavigator</code> unlike the <code>Navigator</code>:</p> <ul> <li>Doesn\u2019t handle back presses, because the tabs are siblings</li> <li>Doesn\u2019t implement the Stack API, just provides a <code>current</code> property</li> </ul> <p>You can use it with a Scaffold to easily create the UI for your tabs.</p> <pre><code>setContent {\n    TabNavigator(HomeTab) {\n        Scaffold(\n            content = { \n                CurrentTab() \n            },\n            bottomBar = {\n                BottomNavigation {\n                    TabNavigationItem(HomeTab)\n                    TabNavigationItem(FavoritesTab)\n                    TabNavigationItem(ProfileTab)\n                }\n            }\n        )\n    }\n}\n</code></pre> <p>Warning</p> <p>Like the<code>CurrentScreen()</code>, you should use <code>CurrentTab</code> instead of <code>tabNavigator.current.Content()</code>, because it will save the Tab\u2019s subtree for you (see SaveableStateHolder).</p> <p>Use the <code>LocalTabNavigator</code> to get the current <code>TabNavigator</code>, and <code>current</code> to get and set the current tab.</p> <pre><code>@Composable\nprivate fun RowScope.TabNavigationItem(tab: Tab) {\n    val tabNavigator = LocalTabNavigator.current\n\n    BottomNavigationItem(\n        selected = tabNavigator.current == tab,\n        onClick = { tabNavigator.current = tab },\n        icon = { Icon(painter = tab.icon, contentDescription = tab.title) }\n    )\n}\n</code></pre>"},{"location":"navigation/tab-navigation/#sample","title":"Sample","text":"<p>Info</p> <p>Source code here.</p>"},{"location":"navigation/tab-navigation/#tabnavigator-nested-navigator","title":"TabNavigator + Nested Navigator","text":"<p>For more complex use cases, when each tab should have its own independent navigation, like the Youtube app, you can combine the <code>TabNavigator</code> with multiple <code>Navigator</code>s.</p> <p>Let\u2019s go back to the Tab navigation example.</p> <pre><code>setContent {\n    TabNavigator(HomeTab) {\n        // ...\n    }\n}\n</code></pre> <p>But now, the <code>HomeTab</code> will have its own <code>Navigator</code>.</p> <pre><code>object HomeTab : Screen {\n\n    @Composable\n    override fun Content() {\n        Navigator(PostListScreen())\n    }\n}\n</code></pre> <p>That way, we can use the <code>LocalNavigator</code> to navigate deeper into <code>HomeTab</code>, or the <code>LocalTabNavigator</code> to switch between tabs.</p> <pre><code>class PostListScreen : Screen {\n\n    @Composable\n    private fun GoToPostDetailsScreenButton(post: Post) {\n        val navigator = LocalNavigator.currentOrThrow\n\n        Button(\n            onClick = { navigator.push(PostDetailsScreen(post.id)) }\n        )\n    }\n\n    @Composable\n    private fun GoToProfileTabButton() {\n        val tabNavigator = LocalTabNavigator.current\n\n        Button(\n            onClick = { tabNavigator.current = ProfileTab }\n        )\n    }\n}\n</code></pre>"},{"location":"screenmodel/","title":"ScreenModel","text":"<p>Success</p> <p>The ScreenModel API is a part of the module<code>cafe.adriel.voyager:voyager-screenmodel</code> (see Setup).</p> <p><code>ScreenModel</code> is just like a ViewModel: designed to store and manage UI-related data in a lifecycle conscious way. It also allows data to survive configuration changes such as screen rotations.</p> <p>Unlike <code>ViewModel</code>, <code>ScreenModel</code> is just an interface. It\u2019s also Android independent and doesn\u2019t requires an <code>Activity</code> or <code>Fragment</code> to work.</p> <pre><code>class HomeScreenModel : ScreenModel {\n\n   // Optional\n    override fun onDispose() {\n        // ...\n    }\n}\n</code></pre> <p>Info</p> <p><code>ScreenModel</code> is integrated with Coroutines, RxJava, LiveData, Koin, Kodein and Hilt!</p> <p>By design, it\u2019s only possible to create a <code>ScreenModel</code> instance inside a <code>Screen</code>. Call <code>rememberScreenModel</code> and provide a factory lambda.</p> <pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = rememberScreenModel { HomeScreenModel() }\n        // ...\n    }\n}\n</code></pre> <p>If you need to have multiple instances of the same <code>ScreenModel</code> for the same <code>Screen</code>, add a tag to differentiate them.</p> <pre><code>val screenModel = rememberScreenModel(tag = \"CUSTOM_TAG\") { HomeScreenModel() }\n</code></pre>"},{"location":"screenmodel/#sample","title":"Sample","text":"<p>Info</p> <p>Source code here.</p>"},{"location":"screenmodel/#navigator-scoped-screenmodel","title":"Navigator scoped ScreenModel","text":"<p>Success</p> <p>The<code>rememberNavigatorScreenModel</code> are part of the navigator library.</p> <p>Starting from <code>1.0.0rc08</code> by using the new Navigator extension called <code>rememberNavigatorScreenModel</code> is possible to have a ScreenModel that is shared cross all Screens from a Navigator and when the Navigator leaves the Composition the ScreenModel is disposed.</p> <pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val navigator = LocalNavigator.currentOrThrow\n        val screenModel = navigator.rememberNavigatorScreenModel { HomeScreenModel() }\n        // ...\n    }\n}\n</code></pre> <p>Info</p> <p>Each DI library we provide a extension out of the box it is also provided support for Navigator scoped ScreenModel. See Koin, Kodein and Hit!</p>"},{"location":"screenmodel/coroutines-integration/","title":"Coroutines integration","text":"<p>Success</p> <p>The <code>screenModelScope</code> and <code>StateScreenModel</code>are part of the core library.</p>"},{"location":"screenmodel/coroutines-integration/#coroutinescope","title":"CoroutineScope","text":"<p>The <code>ScreenModel</code> provides a <code>screenModelScope</code> property. It\u2019s canceled automatically when the <code>ScreenModel</code> is disposed.</p> <pre><code>class PostDetailsScreenModel(\n    private val repository: PostRepository\n) : ScreenModel {\n\n    fun getPost(id: String) {\n        screenModelScope.launch {\n            val post = repository.getPost(id)\n            // ...\n        }\n    }\n}\n</code></pre>"},{"location":"screenmodel/coroutines-integration/#state-aware-screenmodel","title":"State-aware ScreenModel","text":"<p>If your <code>ScreenModel</code> needs to provide a state, use the <code>StateScreenModel</code>. Set the initial state on the constructor and use <code>mutableState</code> to change the current state.</p> <pre><code>class PostDetailsScreenModel(\n    private val repository: PostRepository\n) : StateScreenModel&lt;PostDetailsScreenModel.State&gt;(State.Init) {\n\n    sealed class State {\n        object Init : State()\n        object Loading : State()\n        data class Result(val post: Post) : State()\n    }\n\n    fun getPost(id: String) {\n        coroutineScope.launch {\n            mutableState.value = State.Loading\n            mutableState.value = State.Result(post = repository.getPost(id))\n        }\n    }\n}\n</code></pre> <p>In your screen use <code>state.collectAsState()</code> and handle the current state.</p> <pre><code>class PostDetailsScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = rememberScreenModel&lt;PostDetailsScreenModel&gt;()\n        val state by screenModel.state.collectAsState()\n\n        when (state) {\n            is State.Loading -&gt; LoadingContent()\n            is State.Result -&gt; PostContent(state.post)\n        }\n    }\n}\n</code></pre>"},{"location":"screenmodel/coroutines-integration/#sample","title":"Sample","text":"<p>Info</p> <p>Sample code here.</p>"},{"location":"screenmodel/coroutines-integration/#desktop-note","title":"Desktop Note","text":"<p>Info</p> <p>If you are targeting Desktop, you should provide the dependency <code>org.jetbrains.kotlinx:kotlinx-coroutines-swing</code>, the <code>screenModelScope</code> depends on <code>Dispatchers.Main</code> provided by this library on Desktop. We don\u2019t include it because this library is incompatible with IntelliJ Plugin, see. If you are targeting Desktop for IntelliJ plugins, this library does not require to be provided.</p>"},{"location":"screenmodel/hilt-integration/","title":"Hilt integration","text":"<p>Success</p> <p>To use the <code>getScreenModel</code> you should first import <code>cafe.adriel.voyager:voyager-hilt</code> (see Setup).</p>"},{"location":"screenmodel/hilt-integration/#inject","title":"@Inject","text":"<p>Add <code>@Inject</code> annotation to your <code>ScreenModel</code>.</p> <pre><code>class HomeScreenModel @Inject constructor() : ScreenModel {\n    // ...\n}\n</code></pre> <p>Call <code>getScreenModel()</code> to get a new instance.</p> <pre><code>class HomeScreen : AndroidScreen() {\n\n    @Composable\n    override fun Content() {\n        val screenModel = getScreenModel&lt;HomeScreenModel&gt;()\n        // ...\n    }\n}\n</code></pre>"},{"location":"screenmodel/hilt-integration/#assistedinject","title":"@AssistedInject","text":"<p>Add <code>@AssistedInject</code> annotation to your <code>ScreenModel</code> and provide a <code>ScreenModelFactory</code> annotated with <code>@AssistedFactory</code>.</p> <pre><code>class PostDetailsScreenModel @AssistedInject constructor(\n    @Assisted val postId: Long\n) : ScreenModel {\n\n    @AssistedFactory\n    interface Factory : ScreenModelFactory {\n        fun create(postId: Long): PostDetailsScreenModel\n    }\n}\n</code></pre> <p>Call <code>getScreenModel()</code> and use your factory to create a new instance.</p> <pre><code>data class PostDetailsScreen(val postId: Long): AndroidScreen() {\n\n    @Composable\n    override fun Content() {\n        val screenModel = getScreenModel&lt;PostDetailsScreenModel, PostDetailsScreenModel.Factory&gt; { factory -&gt;\n            factory.create(postId)\n        }\n        // ...\n    }\n}\n</code></pre>"},{"location":"screenmodel/hilt-integration/#sample","title":"Sample","text":"<p>Info</p> <p>Sample code here.</p>"},{"location":"screenmodel/hilt-integration/#navigator-scoped-screenmodel","title":"Navigator scoped ScreenModel","text":"<pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val navigator = LocalNavigator.currentOrThrow\n        val screenModel = navigator.getNavigatorScreenModel&lt;HomeScreenModel&gt;()\n        // ...\n    }\n}\n</code></pre>"},{"location":"screenmodel/kodein-integration/","title":"Kodein integration","text":"<p>Success</p> <p>To use the <code>rememberScreenModel</code> you should first import <code>cafe.adriel.voyager:voyager-kodein</code> (see Setup).</p> <p>Declare your <code>ScreenModel</code>s using the <code>bindProvider</code> bind.</p> <pre><code>val homeModule = DI.Module(name = \"home\") {\n    bindProvider { HomeScreenModel() } \n}\n</code></pre> <p>Call <code>rememberScreenModel()</code> to get a new instance.</p> <pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = rememberScreenModel&lt;HomeScreenModel&gt;()\n        // ...\n    }\n}\n</code></pre>"},{"location":"screenmodel/kodein-integration/#sample","title":"Sample","text":"<p>Info</p> <p>Sample code here.</p>"},{"location":"screenmodel/kodein-integration/#navigator-scoped-screenmodel","title":"Navigator scoped ScreenModel","text":"<pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val navigator = LocalNavigator.currentOrThrow\n        val screenModel = navigator.rememberNavigatorScreenModel&lt;HomeScreenModel&gt;()\n        // ...\n    }\n}\n</code></pre>"},{"location":"screenmodel/koin-integration/","title":"Koin integration","text":"<p>Success</p> <p>To use the <code>getScreenModel</code> you should first import <code>cafe.adriel.voyager:voyager-koin</code> (see Setup).</p> <p>Warning</p> <p>Since 1.1.0-alpha04 we have rename the <code>getScreenModel</code> to <code>koinScreenModel</code>, this is a change to follow Koin Compose naming schema. The previous <code>getScreenModel</code> is deprecated and will be removed on 1.1.0</p> <p>Declare your <code>ScreenModel</code>s using the <code>factory</code> component.</p> <pre><code>val homeModule = module {\n    factory { HomeScreenModel() } \n}\n</code></pre> <p>Call <code>getScreenModel()</code> to get a new instance.</p> <pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = getScreenModel&lt;HomeScreenModel&gt;()\n        // ...\n    }\n}\n</code></pre>"},{"location":"screenmodel/koin-integration/#sample","title":"Sample","text":"<p>Info</p> <p>Sample code here.</p>"},{"location":"screenmodel/koin-integration/#navigator-scoped-screenmodel","title":"Navigator scoped ScreenModel","text":"<pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val navigator = LocalNavigator.currentOrThrow\n        val screenModel = navigator.getNavigatorScreenModel&lt;HomeScreenModel&gt;()\n        // ...\n    }\n}\n</code></pre>"},{"location":"screenmodel/livedata-integration/","title":"LiveData integration","text":"<p>Success</p> <p>To use the <code>LiveScreenModel</code> you should first import <code>cafe.adriel.voyager:voyager-livedata</code> (see Setup).</p>"},{"location":"screenmodel/livedata-integration/#state-aware-screenmodel","title":"State-aware ScreenModel","text":"<p>If your <code>ScreenModel</code> needs to provide a state, use the <code>LiveScreenModel</code>. Set the initial state on the constructor and use <code>mutableState</code> to change the current state.</p> <pre><code>class PostDetailsScreenModel(\n    private val repository: PostRepository\n) : LiveScreenModel&lt;PostDetailsScreenModel.State&gt;(State.Init) {\n\n    sealed class State {\n        object Init : State()\n        object Loading : State()\n        data class Result(val post: Post) : State()\n    }\n\n    fun getPost(id: String) {\n        coroutineScope.launch {\n            val result = State.Result(post = repository.getPost(id))\n            mutableState.postValue(result)\n        }\n    }\n}\n</code></pre> <p>In your screen use <code>state.observeAsState()</code> and handle the current state.</p> <pre><code>class PostDetailsScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = rememberScreenModel&lt;PostDetailsScreenModel&gt;()\n        val state by screenModel.state.observeAsState()\n\n        when (state) {\n            is State.Loading -&gt; LoadingContent()\n            is State.Result -&gt; PostContent(state.post)\n        }\n    }\n}\n</code></pre>"},{"location":"screenmodel/livedata-integration/#sample","title":"Sample","text":"<p>Info</p> <p>Sample code here.</p>"},{"location":"screenmodel/rxjava-integration/","title":"RxJava integration","text":"<p>Success</p> <p>To use the <code>disposables</code> and <code>RxScreenModel</code> you should first import <code>cafe.adriel.voyager:voyager-rxjava</code> (see Setup).</p>"},{"location":"screenmodel/rxjava-integration/#compositedisposable","title":"CompositeDisposable","text":"<p>The <code>ScreenModel</code> provides a <code>disposables</code> property. It\u2019s cleared automatically when the <code>ScreenModel</code> is disposed.</p> <pre><code>class PostDetailsScreenModel(\n    private val repository: PostRepository\n) : ScreenModel {\n\n    fun getPost(id: String) {\n        repository.getPost(id)\n            .subscribe { post -&gt; /* ... */ }\n            .let(disposables::add)\n    }\n}\n</code></pre>"},{"location":"screenmodel/rxjava-integration/#state-aware-screenmodel","title":"State-aware ScreenModel","text":"<p>If your <code>ScreenModel</code> needs to provide a state, use the <code>RxScreenModel</code>. Use <code>mutableState</code> to change the current state.</p> <pre><code>class PostDetailsScreenModel(\n    private val repository: PostRepository\n) : RxScreenModel&lt;PostDetailsScreenModel.State&gt;() {\n\n    sealed class State {\n        object Init : State()\n        object Loading : State()\n        data class Result(val post: Post) : State()\n    }\n\n    fun getPost(id: String) {\n        repository.getPost(id)\n            .doOnSubscribe { mutableState.onNext(State.Loading) }\n            .subscribe { post -&gt; mutableState.onNext(State.Result(post)) }\n            .let(disposables::add)\n    }\n}\n</code></pre> <p>In your screen use <code>state.subscribeAsState()</code> and handle the current state.</p> <pre><code>class PostDetailsScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = rememberScreenModel&lt;PostDetailsScreenModel&gt;()\n        val state by screenModel.state.subscribeAsState(initial = State.Init)\n\n        when (state) {\n            is State.Loading -&gt; LoadingContent()\n            is State.Result -&gt; PostContent(state.post)\n        }\n    }\n}\n</code></pre>"},{"location":"screenmodel/rxjava-integration/#sample","title":"Sample","text":"<p>Info</p> <p>Sample code here.</p>"}]}